static void e100_nic_realize(PCIDevice *pci_dev, Error **errp) EEPRO100State * s = DO_UPCAST ( EEPRO100State , dev , pci_dev ) ; E100PCIDeviceInfo * info = eepro100_get_class ( s ) ; static E100PCIDeviceInfo *eepro100_get_class(EEPRO100State *s) return eepro100_get_class_by_name ( object_get_typename ( OBJECT ( s ) ) ) ; static E100PCIDeviceInfo *eepro100_get_class_by_name(const char *typename) E100PCIDeviceInfo * info = NULL ; int i ; for (i = 0; i < ARRAY_SIZE(e100_devices); i++) if ( strcmp ( e100_devices [ i ] . name , typename ) == 0 )  info = & e100_devices [ i ]; return info ; s -> device = info -> device; s -> eeprom = eeprom93xx_new ( & pci_dev -> qdev , EEPROM_SIZE ); nic_reset ( s ); static void nic_reset(void *opaque) EEPRO100State * s = opaque ; memset ( & s -> mult [ 0 ] , 0 , sizeof ( s -> mult ) ); nic_selective_reset ( s ); static void nic_selective_reset(EEPRO100State * s) uint16_t * eeprom_contents = eeprom93xx_data ( s -> eeprom ) ; eeprom93xx_reset ( s -> eeprom ); memcpy ( eeprom_contents , s -> conf . macaddr . a , 6 ); eeprom_contents [ EEPROM_ID ] = EEPROM_ID_VALID; if ( s -> device == i82557B || s -> device == i82557C )  eeprom_contents [ 5 ] = 0x0100; eeprom_contents [ EEPROM_PHY_ID ] = 1; sum += eeprom_contents [ i ]; eeprom_contents [ EEPROM_SIZE - 1 ] = 0xbaba - sum; TRACE ( EEPROM , logout ( "checksum=0x%04x\n" , eeprom_contents [ EEPROM_SIZE - 1 ] ) ); memset ( s -> mem , 0 , sizeof ( s -> mem ) ); e100_write_reg4 ( s , SCBCtrlMDI , BIT ( 21 ) ); static void e100_write_reg4(EEPRO100State *s, E100RegisterOffset uint32_t val) assert ( ! ( ( uintptr_t ) & s -> mem [ addr ] & 3 ) ); cpu_to_le32w ( ( uint32_t * ) & s -> mem [ addr ] , val ); assert ( sizeof ( s -> mdimem ) == sizeof ( eepro100_mdi_default ) ); memcpy ( & s -> mdimem [ 0 ] , & eepro100_mdi_default [ 0 ] , sizeof ( s -> mdimem ) ); 