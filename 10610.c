static int arcmsr_queue_command_lck(struct scsi_cmnd void (* done)(struct scsi_cmnd *)) struct Scsi_Host * host = cmd -> device -> host ; struct AdapterControlBlock * acb = ( struct AdapterControlBlock * ) host -> hostdata ; struct CommandControlBlock * ccb ; int target = cmd -> device -> id ; uint8_t scsicmd = cmd -> cmnd [ 0 ] ; if ( ( scsicmd == SYNCHRONIZE_CACHE ) || ( scsicmd == SEND_DIAGNOSTIC ) )  if ( target == 16 )  ccb = arcmsr_get_freeccb ( acb ); static struct CommandControlBlock *arcmsr_get_freeccb(struct AdapterControlBlock *acb) struct list_head * head = & acb -> ccb_free_list ; struct CommandControlBlock * ccb = NULL ; if ( ! list_empty ( head ) )  ccb = list_entry ( head -> next , struct CommandControlBlock , list ) return NULL ; return ccb ; if ( ! ccb )  if ( arcmsr_build_ccb ( acb , ccb , cmd ) == FAILED )  static int arcmsr_build_ccb(struct AdapterControlBlock struct CommandControlBlock *ccb, struct scsi_cmnd *pcmd) struct ARCMSR_CDB * arcmsr_cdb = ( struct ARCMSR_CDB * ) & ccb -> arcmsr_cdb ; memset ( arcmsr_cdb , 0 , sizeof ( struct ARCMSR_CDB ) ); arcmsr_cdb -> TargetID = pcmd -> device -> id; arcmsr_cdb -> LUN = pcmd -> device -> lun; arcmsr_cdb -> Function = 1; arcmsr_cdb -> msgContext = 0; memcpy ( arcmsr_cdb -> Cdb , pcmd -> cmnd , pcmd -> cmd_len ); arcmsr_cdb -> sgcount = ( uint8_t ) nseg; arcmsr_cdb -> DataLength = scsi_bufflen ( pcmd ); arcmsr_cdb -> msgPages = arccdbsize / 0x100 + ( arccdbsize % 0x100 ? 1 : 0 ); arcmsr_cdb -> Flags |= ARCMSR_CDB_FLAG_SGL_BSIZE; arcmsr_cdb -> Flags |= ARCMSR_CDB_FLAG_WRITE; 