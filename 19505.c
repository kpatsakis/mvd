XML_Parser XML_ExternalEntityParserCreate(XML_Parser const XML_Char const XML_Char *encodingName) XML_Parser parser = oldParser ; DTD * newDtd = NULL ; DTD * oldDtd = _dtd ; if ( ! context )  newDtd = oldDtd; if ( ns )  parser = parserCreate ( encodingName , & parser -> m_mem , NULL , newDtd ); static parserCreate(const XML_Char const XML_Memory_Handling_Suite const XML_Char DTD *dtd) XML_Parser parser ; if ( memsuite )  parser = ( XML_Parser ) malloc ( sizeof ( struct XML_ParserStruct ) ); if ( parser != NULL )  mtemp = ( XML_Memory_Handling_Suite * ) & ( parser -> m_mem ); mtemp -> malloc_fcn = malloc; mtemp -> realloc_fcn = realloc; mtemp -> free_fcn = free; if ( ! parser )  return parser ; FREE ( parser ); FREE ( parser ); _dtd = dtdCreate ( & parser -> m_mem ); static DTD dtdCreate(const XML_Memory_Handling_Suite *ms) DTD * p = ( DTD * ) ms -> malloc_fcn ( sizeof ( DTD ) ) ; if ( p == NULL )  return p ; poolInit ( & ( p -> pool ) , ms ); static void poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms) pool -> blocks = NULL; pool -> freeBlocks = NULL; pool -> start = NULL; pool -> ptr = NULL; pool -> end = NULL; pool -> mem = ms; poolInit ( & ( p -> entityValuePool ) , ms ); static void poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms) pool -> blocks = NULL; pool -> freeBlocks = NULL; pool -> start = NULL; pool -> ptr = NULL; pool -> end = NULL; pool -> mem = ms; hashTableInit ( & ( p -> generalEntities ) , ms ); static void hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) p -> power = 0; p -> size = 0; p -> used = 0; p -> v = NULL; p -> mem = ms; hashTableInit ( & ( p -> elementTypes ) , ms ); static void hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) p -> power = 0; p -> size = 0; p -> used = 0; p -> v = NULL; p -> mem = ms; hashTableInit ( & ( p -> attributeIds ) , ms ); static void hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) p -> power = 0; p -> size = 0; p -> used = 0; p -> v = NULL; p -> mem = ms; hashTableInit ( & ( p -> prefixes ) , ms ); static void hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) p -> power = 0; p -> size = 0; p -> used = 0; p -> v = NULL; p -> mem = ms; p -> paramEntityRead = XML_FALSE; hashTableInit ( & ( p -> paramEntities ) , ms ); static void hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) p -> power = 0; p -> size = 0; p -> used = 0; p -> v = NULL; p -> mem = ms; p -> defaultPrefix . name = NULL; p -> defaultPrefix . binding = NULL; p -> in_eldecl = XML_FALSE; p -> scaffIndex = NULL; p -> scaffold = NULL; p -> scaffLevel = 0; p -> scaffSize = 0; p -> scaffCount = 0; p -> contentStringLen = 0; p -> keepProcessing = XML_TRUE; p -> hasParamEntityRefs = XML_FALSE; p -> standalone = XML_FALSE; return p ; if ( _dtd == NULL )  FREE ( parser ); poolInit ( & tempPool , & ( parser -> m_mem ) ); static void poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms) pool -> blocks = NULL; pool -> freeBlocks = NULL; pool -> start = NULL; pool -> ptr = NULL; pool -> end = NULL; pool -> mem = ms; poolInit ( & temp2Pool , & ( parser -> m_mem ) ); static void poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms) pool -> blocks = NULL; pool -> freeBlocks = NULL; pool -> start = NULL; pool -> ptr = NULL; pool -> end = NULL; pool -> mem = ms; parserInit ( parser , encodingName ); static parserInit(XML_Parser parser, const XML_Char *encodingName) protocolEncodingName = ( encodingName != NULL ? poolCopyString ( & tempPool , encodingName ) : NULL ); static const XML_Char * poolCopyString(STRING_POOL *pool, const XML_Char *s) if ( ! poolAppendChar ( pool , * s ) )  while ( * s ++ )  s = pool -> start; poolFinish ( pool ); return s ; externalEntityRefHandlerArg = parser; XML_ParserFree ( parser ); void XML_ParserFree(XML_Parser parser) if ( parser == NULL )  destroyBindings ( p -> bindings , parser ); static void destroyBindings(BINDING *bindings, XML_Parser parser) BINDING * b = bindings ; if ( ! b )  bindings = b -> nextTagBinding; FREE ( b -> uri ); FREE ( b ); destroyBindings ( freeBindingList , parser ); static void destroyBindings(BINDING *bindings, XML_Parser parser) BINDING * b = bindings ; if ( ! b )  bindings = b -> nextTagBinding; FREE ( b -> uri ); FREE ( b ); destroyBindings ( inheritedBindings , parser ); static void destroyBindings(BINDING *bindings, XML_Parser parser) BINDING * b = bindings ; if ( ! b )  bindings = b -> nextTagBinding; FREE ( b -> uri ); FREE ( b ); dtdDestroy ( _dtd , ( XML_Bool ) ! parentParser , & parser -> m_mem ); static dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms) hashTableIterInit ( & iter , & ( p -> elementTypes ) ); static void hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table) iter -> p = table -> v; iter -> end = iter -> p + table -> size; ms -> free_fcn ( e -> defaultAtts ); hashTableDestroy ( & ( p -> generalEntities ) ); static void hashTableDestroy(HASH_TABLE *table) for (i = 0; i < table->size; i++) table -> mem -> free_fcn ( table -> v [ i ] ); table -> mem -> free_fcn ( table -> v ); hashTableDestroy ( & ( p -> paramEntities ) ); static void hashTableDestroy(HASH_TABLE *table) table -> mem -> free_fcn ( table -> v [ i ] ); table -> mem -> free_fcn ( table -> v ); hashTableDestroy ( & ( p -> elementTypes ) ); static void hashTableDestroy(HASH_TABLE *table) table -> mem -> free_fcn ( table -> v [ i ] ); table -> mem -> free_fcn ( table -> v ); hashTableDestroy ( & ( p -> attributeIds ) ); static void hashTableDestroy(HASH_TABLE *table) table -> mem -> free_fcn ( table -> v [ i ] ); table -> mem -> free_fcn ( table -> v ); hashTableDestroy ( & ( p -> prefixes ) ); static void hashTableDestroy(HASH_TABLE *table) table -> mem -> free_fcn ( table -> v [ i ] ); table -> mem -> free_fcn ( table -> v ); poolDestroy ( & ( p -> pool ) ); static void poolDestroy(STRING_POOL *pool) BLOCK * p = pool -> blocks ; while ( p )  BLOCK * tem = p -> next ; pool -> mem -> free_fcn ( p ); p = tem; p = pool -> freeBlocks; while ( p )  BLOCK * tem = p -> next ; pool -> mem -> free_fcn ( p ); p = tem; poolDestroy ( & ( p -> entityValuePool ) ); static void poolDestroy(STRING_POOL *pool) BLOCK * p = pool -> blocks ; while ( p )  BLOCK * tem = p -> next ; pool -> mem -> free_fcn ( p ); p = tem; p = pool -> freeBlocks; while ( p )  BLOCK * tem = p -> next ; pool -> mem -> free_fcn ( p ); p = tem; if ( isDocEntity )  ms -> free_fcn ( p -> scaffIndex ); ms -> free_fcn ( p -> scaffold ); ms -> free_fcn ( p ); FREE ( parser ); return parser ; 