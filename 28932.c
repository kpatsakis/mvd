 nestegg_read_packet(nestegg * ctx, nestegg_packet ** pkt) uint64_t id , size ; * pkt = NULL; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( ne_is_suspend_element ( id ) )  static ne_is_suspend_element(uint64_t id) if ( id == ID_SIMPLE_BLOCK || id == ID_BLOCK )  return 1 ; return 0 ; r = ne_read_element ( ctx , & id , & size ); static ne_read_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; r = ne_peek_element ( ctx , id , size ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  r = ne_read_block ( ctx , id , size , pkt ); r = ne_parse ( ctx , NULL , - 1 ); static ne_parse(nestegg * ctx, struct ebml_element_desc * top_level, int64_t max_offset) int r ; int64_t * data_offset ; uint64_t id , size , peeked_id ; struct ebml_element_desc * element ; if ( ! ctx -> ancestor )  return - 1 ; if ( max_offset > 0 && ne_io_tell ( ctx -> io ) >= max_offset )  r = 1; r = ne_peek_element ( ctx , & id , & size ); if ( r != 1 )  element = ne_find_element ( id , ctx -> ancestor -> node ); if ( element )  if ( element -> flags & DESC_FLAG_SUSPEND )  r = 1; r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  if ( element -> flags & DESC_FLAG_OFFSET )  data_offset = ( int64_t * ) ( ctx -> ancestor -> data + element -> data_offset ); * data_offset = ne_io_tell ( ctx -> io ); if ( * data_offset < 0 )  r = - 1; if ( element -> type == TYPE_MASTER )  if ( element -> flags & DESC_FLAG_MULTI )  if ( ne_read_master ( ctx , element ) < 0 )  if ( ne_read_single_master ( ctx , element ) < 0 )  r = ne_read_simple ( ctx , element , size ); if ( r < 0 )  if ( ne_is_ancestor_element ( id , ctx -> ancestor -> previous ) )  if ( top_level && ctx -> ancestor -> node == top_level )  r = 1; r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  r = ne_io_read_skip ( ctx -> io , size ); if ( r != 1 )  return r ; if ( r != 1 )  static ne_read_block(nestegg * ctx, uint64_t block_id, uint64_t block_size, nestegg_packet ** data) int r ; struct cluster * cluster ; struct track_entry * entry ; uint64_t track_number , length , frame_sizes [ 256 ] , cluster_tc , flags , frames , tc_scale , total ; unsigned int i , lacing , track ; size_t consumed = 0 ; if ( block_size > LIMIT_BLOCK )  r = ne_read_vint ( ctx -> io , & track_number , & length ); static ne_read_vint(nestegg_io * io, uint64_t * value, uint64_t * length) return ne_bare_read_vint ( io , value , length , MASK_FIRST_BIT ) ; if ( r != 1 )  if ( track_number == 0 )  consumed += length; r = ne_read_int ( ctx -> io , & timecode , 2 ); static ne_read_int(nestegg_io * io, int64_t * val, uint64_t length) int r ; r = ne_read_uint ( io , & uval , length ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  consumed += 2; r = ne_read_uint ( ctx -> io , & flags , 1 ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) int r ; if ( length == 0 || length > 8 )  return - 1 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  consumed += 1; frames = 0; lacing = ( flags & BLOCK_FLAGS_LACING ) >> 1; switch ( lacing )  frames = 1; r = ne_read_uint ( ctx -> io , & frames , 1 ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) int r ; if ( length == 0 || length > 8 )  return - 1 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  consumed += 1; frames += 1; if ( frames > 256 )  switch ( lacing )  frame_sizes [ 0 ] = block_size - consumed; if ( frames == 1 )  r = ne_read_xiph_lacing ( ctx -> io , block_size , & consumed , frames , frame_sizes ); static ne_read_xiph_lacing(nestegg_io * io, size_t block, size_t * read, uint64_t n, uint64_t * sizes) int r ; size_t i = 0 ; uint64_t sum = 0 ; while ( -- n )  r = ne_read_xiph_lace_value ( io , & sizes [ i ] , read ); static ne_read_xiph_lace_value(nestegg_io * io, uint64_t * value, size_t * consumed) int r ; uint64_t lace ; r = ne_read_uint ( io , & lace , 1 ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) int r ; if ( length == 0 || length > 8 )  return - 1 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; while ( lace == 255 )  r = ne_read_uint ( io , & lace , 1 ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) int r ; if ( length == 0 || length > 8 )  return - 1 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; sum += sizes [ i ]; i += 1; if ( * read + sum > block )  return - 1 ; return 1 ; if ( r != 1 )  if ( ( block_size - consumed ) % frames )  for (i = 0; i < frames; ++i) frame_sizes [ i ] = ( block_size - consumed ) / frames; if ( frames == 1 )  r = ne_read_ebml_lacing ( ctx -> io , block_size , & consumed , frames , frame_sizes ); static ne_read_ebml_lacing(nestegg_io * io, size_t block, size_t * read, uint64_t n, uint64_t * sizes) int r ; uint64_t lace , sum , length ; int64_t slace ; size_t i = 0 ; r = ne_read_vint ( io , & lace , & length ); static ne_read_vint(nestegg_io * io, uint64_t * value, uint64_t * length) return ne_bare_read_vint ( io , value , length , MASK_FIRST_BIT ) ; if ( r != 1 )  return r ; * read += length; sizes [ i ] = lace; sum = sizes [ i ]; i += 1; n -= 1; while ( -- n )  r = ne_read_svint ( io , & slace , & length ); static ne_read_svint(nestegg_io * io, int64_t * value, uint64_t * length) int r ; r = ne_bare_read_vint ( io , & uvalue , & ulength , MASK_FIRST_BIT ); static ne_bare_read_vint(nestegg_io * io, uint64_t * value, uint64_t * length, enum vint_mask maskflag) int r ; unsigned char b ; size_t maxlen = 8 ; unsigned int count = 1 , mask = 1 << 7 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( count < maxlen )  if ( ( b & mask ) != 0 )  mask >>= 1; count += 1; while ( -- count )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; return r ; if ( r != 1 )  return r ; * read += length; sizes [ i ] = sizes [ i - 1 ] + slace; sum += sizes [ i ]; i += 1; if ( * read + sum > block )  return - 1 ; return 1 ; if ( r != 1 )  total = consumed; for (i = 0; i < frames; ++i) total += frame_sizes [ i ]; if ( total > block_size )  if ( ne_map_track_number_to_index ( ctx , track_number , & track ) != 0 )  entry = ne_find_track_entry ( ctx , track ); static struct track_entry ne_find_track_entry(nestegg * ctx, unsigned int track) struct ebml_list_node * node ; unsigned int tracks = 0 ; node = ctx -> segment . tracks . track_entry . head; while ( node )  if ( track == tracks )  return node -> data ; tracks += 1; node = node -> next; return NULL ; if ( ! entry )  cluster = ctx -> segment . cluster . tail -> data; if ( ne_get_uint ( cluster -> timecode , & cluster_tc ) != 0 )  static ne_get_uint(struct ebml_type type, uint64_t * value) if ( ! type . read )  assert ( type . type == TYPE_UINT ); 