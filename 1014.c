static dissect_iax2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) proto_item * iax2_item ; proto_tree * iax2_tree ; guint32 offset = 0 , len ; guint16 scallno = 0 ; guint16 stmp ; packet_type type ; proto_item * full_mini_base ; iax2_item = proto_tree_add_item ( tree , proto_iax2 , tvb , offset , - 1 , ENC_NA ); iax2_tree = proto_item_add_subtree ( iax2_item , ett_iax2 ); stmp = tvb_get_ntohs ( tvb , offset ); if ( stmp == 0 )  offset += 2; stmp = tvb_get_ntohs ( tvb , offset ); if ( stmp & 0x8000 )  type = IAX2_MINI_VIDEO_PACKET; scallno = stmp & 0x7FFF; offset += 2; type = IAX2_TRUNK_PACKET; scallno = tvb_get_ntohs ( tvb , offset ); offset += 2; if ( scallno & 0x8000 )  type = IAX2_FULL_PACKET; type = IAX2_MINI_VOICE_PACKET; scallno &= 0x7FFF; full_mini_base = proto_tree_add_uint ( iax2_tree , hf_iax2_packet_type , tvb , 0 , offset , type ); full_mini_subtree = proto_item_add_subtree ( full_mini_base , ett_iax2_full_mini_subtree ); switch ( type )  len = dissect_fullpacket ( tvb , offset , scallno , pinfo , full_mini_subtree , tree ); static dissect_fullpacket(tvbuff_t *tvb, guint32 guint16 packet_info *pinfo, proto_tree proto_tree *main_tree) guint16 dcallno ; guint8 type ; guint8 csub ; proto_tree * packet_type_tree = NULL ; iax_call_data * iax_call ; iax_packet_data * iax_packet ; gboolean reversed ; dcallno = tvb_get_ntohs ( tvb , offset ) & 0x7FFF; type = tvb_get_guint8 ( tvb , offset + 8 ); csub = tvb_get_guint8 ( tvb , offset + 9 ); iax_packet = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 ); if ( ! iax_packet )  if ( type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW )  iax_call = iax_new_call ( pinfo , scallno ); static iax_call_data *iax_new_call( packet_info guint32 scallno) iax_call_data * call ; call = wmem_new ( wmem_file_scope ( ) , iax_call_data ); call -> dataformat = AST_DATAFORMAT_NULL; call -> src_codec = 0; call -> dst_codec = 0; call -> n_forward_circuit_ids = 0; call -> n_reverse_circuit_ids = 0; call -> subdissector = NULL; call -> start_time = pinfo -> fd -> abs_ts; return call ; reversed = FALSE; iax_call = iax_lookup_call ( pinfo , scallno , dcallno , & reversed ); static iax_call_data *iax_lookup_call( packet_info guint32 guint32 gboolean *reversed_p) iax_call_data * iax_call = NULL ; guint src_circuit_id ; src_circuit_id = iax_circuit_lookup ( & pinfo -> src , pinfo -> ptype , pinfo -> srcport , scallno ); static guint iax_circuit_lookup(const address port_type guint32 guint32 callno) iax_circuit_key key ; guint32 * circuit_id_p ; key . addr = * address_p; key . ptype = ptype; key . port = port; key . callno = callno; circuit_id_p = ( guint32 * ) g_hash_table_lookup ( iax_circuit_hashtab , & key ); if ( ! circuit_id_p )  circuit_id_p = ( guint32 * ) wmem_new ( wmem_file_scope ( ) , iax_circuit_key ); * circuit_id_p = ++ circuitcount; return * circuit_id_p ; if ( dcallno != 0 )  guint dst_circuit_id ; dst_circuit_id = iax_circuit_lookup ( & pinfo -> dst , pinfo -> ptype , pinfo -> destport , dcallno ); static guint iax_circuit_lookup(const address port_type guint32 guint32 callno) iax_circuit_key key ; guint32 * circuit_id_p ; key . addr = * address_p; key . ptype = ptype; key . port = port; key . callno = callno; circuit_id_p = ( guint32 * ) g_hash_table_lookup ( iax_circuit_hashtab , & key ); if ( ! circuit_id_p )  circuit_id_p = ( guint32 * ) wmem_new ( wmem_file_scope ( ) , iax_circuit_key ); * circuit_id_p = ++ circuitcount; return * circuit_id_p ; iax_call = iax_lookup_call_from_dest ( pinfo , NULL , src_circuit_id , dst_circuit_id , pinfo -> fd -> num , & reversed ); static iax_call_data *iax_lookup_call_from_dest(packet_info *pinfo, proto_item * guint guint guint gboolean *reversed_p) circuit_t * dst_circuit ; iax_call_data * iax_call ; dst_circuit = find_circuit ( CT_IAX2 , dst_circuit_id , framenum ); if ( ! dst_circuit )  return NULL ; iax_call = ( iax_call_data * ) circuit_get_proto_data ( dst_circuit , proto_iax2 ); if ( is_forward_circuit ( dst_circuit_id , iax_call ) )  static gboolean is_forward_circuit(guint const iax_call_data *iax_call) guint i ; for(i=0; i<iax_call->n_forward_circuit_ids; i++) if ( circuit_id == iax_call -> forward_circuit_ids [ i ] )  return TRUE ; return FALSE ; if ( iax_call -> n_reverse_circuit_ids == 0 )  if ( ! is_reverse_circuit ( src_circuit_id , iax_call ) )  static gboolean is_reverse_circuit(guint const iax_call_data *iax_call) guint i ; for(i=0; i<iax_call->n_reverse_circuit_ids; i++) if ( circuit_id == iax_call -> reverse_circuit_ids [ i ] )  return TRUE ; return FALSE ; return NULL ; if ( is_reverse_circuit ( dst_circuit_id , iax_call ) )  static gboolean is_reverse_circuit(guint const iax_call_data *iax_call) guint i ; if ( circuit_id == iax_call -> reverse_circuit_ids [ i ] )  return TRUE ; return FALSE ; if ( ! is_forward_circuit ( src_circuit_id , iax_call ) )  static gboolean is_forward_circuit(guint const iax_call_data *iax_call) guint i ; if ( circuit_id == iax_call -> forward_circuit_ids [ i ] )  return TRUE ; return FALSE ; return NULL ; return iax_call ; circuit_t * src_circuit ; src_circuit = find_circuit ( CT_IAX2 , src_circuit_id , pinfo -> fd -> num ); if ( src_circuit )  iax_call = ( iax_call_data * ) circuit_get_proto_data ( src_circuit , proto_iax2 ); return iax_call ; iax_packet = iax_new_packet_data ( iax_call , reversed ); static iax_packet_data *iax_new_packet_data(iax_call_data *call, gboolean reversed) iax_packet_data * p = wmem_new ( wmem_file_scope ( ) , iax_packet_data ) ; p -> first_time = TRUE; p -> call_data = call; p -> codec = 0; p -> reversed = reversed; p -> abstime . secs = - 1; p -> abstime . nsecs = - 1; return p ; if ( iax2_tree )  proto_item * packet_type_base ; packet_type_base = proto_tree_add_uint ( iax2_tree , hf_iax2_type , tvb , offset + 8 , 1 , type ); packet_type_tree = proto_item_add_subtree ( packet_type_base , ett_iax2_type ); switch ( type )  offset = dissect_iax2_command ( tvb , offset + 9 , pinfo , packet_type_tree , iax_packet ); static guint32 dissect_iax2_command(tvbuff_t *tvb, guint32 packet_info *pinfo, proto_tree iax_packet_data *iax_packet) guint8 csub = tvb_get_guint8 ( tvb , offset ) ; guint8 address_data [ MAX_ADDRESS ] ; proto_item * ti ; iax2_ie_data ie_data ; ie_data . peer_address . type = AT_NONE; ie_data . peer_address . len = 0; ie_data . peer_address . data = address_data; ie_data . peer_ptype = PT_NONE; ie_data . peer_port = 0; ie_data . peer_callno = 0; ie_data . dataformat = ( guint32 ) - 1; ti = proto_tree_add_uint ( tree , hf_iax2_iax_csub , tvb , offset , 1 , csub ); offset ++; if ( offset >= tvb_reported_length ( tvb ) )  offset = dissect_ies ( tvb , pinfo , offset , tree , ti , & ie_data ); static guint32 dissect_ies(tvbuff_t *tvb, packet_info *pinfo, guint32 proto_tree *iax_tree, proto_item * iax2_ie_data *ie_data) while ( offset < tvb_reported_length ( tvb ) )  int ies_type = tvb_get_guint8 ( tvb , offset ) ; int ies_len = tvb_get_guint8 ( tvb , offset + 1 ) ; guint16 apparent_addr_family ; switch ( ies_type )  if ( ies_len != 4 )  ie_data -> dataformat = tvb_get_ntohl ( tvb , offset + 2 ); apparent_addr_family = tvb_get_letohs ( tvb , offset + 2 ); switch ( apparent_addr_family )  ie_data -> peer_ptype = PT_UDP; ie_data -> peer_port = tvb_get_ntohs ( tvb , offset + 4 ); if ( iax_tree && ies_type < NUM_HF_IAX2_IES )  switch ( ies_type )  apparent_addr_family = tvb_get_letohs ( tvb , offset + 2 ); if ( apparent_addr_family == LINUX_AF_INET )  guint32 addr ; memcpy ( & addr , ie_data -> peer_address . data , 4 ); proto_tree_add_ipv4 ( sockaddr_tree , hf_IAX_IE_APPARENTADDR_SINADDR , tvb , offset + 6 , 4 , addr ); offset += ies_len + 2; 