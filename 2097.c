static void eepro100_write_command(EEPRO100State * s, uint8_t val) eepro100_cu_command ( s , val & 0xf0 ); static void eepro100_cu_command(EEPRO100State * s, uint8_t val) switch ( val )  s -> cu_offset = e100_read_reg4 ( s , SCBPointer ); static uint32_t e100_read_reg4(EEPRO100State *s, E100RegisterOffset addr) return le32_to_cpup ( ( uint32_t * ) & s -> mem [ addr ] ) ; if ( get_cu_state ( s ) == cu_suspended )  static cu_state_t get_cu_state(EEPRO100State * s) return ( ( s -> mem [ SCBStatus ] & BITS ( 7 , 6 ) ) >> 6 ) ; action_command ( s ); static void action_command(EEPRO100State *s) bool bit_el ; bool bit_s ; bool bit_nc ; s -> cb_address = s -> cu_base + s -> cu_offset; bit_el = ( ( s -> tx . command & COMMAND_EL ) != 0 ); bit_s = ( ( s -> tx . command & COMMAND_S ) != 0 ); bit_nc = ( ( s -> tx . command & COMMAND_NC ) != 0 ); s -> cu_offset = s -> tx . link; switch ( s -> tx . command & COMMAND_CMD )  if ( bit_nc )  tx_command ( s ); s -> tx . status = 0; if ( bit_el )  if ( bit_s )  static void tx_command(EEPRO100State *s) uint16_t tcb_bytes = ( le16_to_cpu ( s -> tx . tcb_bytes ) & 0x3fff ) ; if ( tcb_bytes > 2600 )  tcb_bytes = 2600; assert ( tcb_bytes <= sizeof ( buf ) ); 