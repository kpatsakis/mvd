static int mov_read_packet(AVFormatContext *s, AVPacket *pkt) MOVContext * mov = s -> priv_data ; MOVStreamContext * sc ; AVIndexEntry * sample ; AVStream * st = NULL ; int ret ; mov -> fc = s; sample = mov_find_next_sample ( s , & st ); static AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st) AVIndexEntry * sample = NULL ; int64_t best_dts = INT64_MAX ; int i ; for (i = 0; i < s->nb_streams; i++) AVStream * avst = s -> streams [ i ] ; MOVStreamContext * msc = avst -> priv_data ; if ( msc -> pb && msc -> current_sample < avst -> nb_index_entries )  AVIndexEntry * current_sample = & avst -> index_entries [ msc -> current_sample ] ; int64_t dts = av_rescale ( current_sample -> timestamp , AV_TIME_BASE , msc -> time_scale ) ; if ( ! sample || ( ! s -> pb -> seekable && current_sample -> pos < sample -> pos ) || ( s -> pb -> seekable && ( ( msc -> pb != s -> pb && dts < best_dts ) || ( msc -> pb == s -> pb && ( ( FFABS ( best_dts - dts ) <= AV_TIME_BASE && current_sample -> pos < sample -> pos ) || ( FFABS ( best_dts - dts ) > AV_TIME_BASE && dts < best_dts ) ) ) ) ) )  sample = current_sample; best_dts = dts; return sample ; if ( ! sample )  sc = st -> priv_data; sc -> current_sample ++; if ( st -> discard != AVDISCARD_ALL )  if ( avio_seek ( sc -> pb , sample -> pos , SEEK_SET ) != sample -> pos )  ret = av_get_packet ( sc -> pb , pkt , sample -> size ); if ( ret < 0 )  if ( sc -> has_palette )  uint8_t * pal ; pal = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ); if ( ! pal )  memcpy ( pal , sc -> palette , AVPALETTE_SIZE ); sc -> has_palette = 0; if ( mov -> dv_demux && sc -> dv_audio_container )  pkt -> size = 0; ret = avpriv_dv_get_packet ( mov -> dv_demux , pkt ); if ( ret < 0 )  if ( sc -> ctts_data && sc -> ctts_index < sc -> ctts_count )  sc -> ctts_sample ++; if ( sc -> ctts_index < sc -> ctts_count && sc -> ctts_data [ sc -> ctts_index ] . count == sc -> ctts_sample )  sc -> ctts_index ++; sc -> ctts_sample = 0; if ( st -> discard == AVDISCARD_ALL )  